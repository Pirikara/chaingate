package ossfmalware

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	bolt "go.etcd.io/bbolt"
)

const (
	// Bucket names
	bucketPackages = "pkgs"
	bucketMetadata = "meta"
	bucketEntries  = "entries" // Store full OSV entries for range matching

	// Metadata keys
	keyLastSHA   = "last_sha"
	keyLastSync  = "last_sync"
	keyEntryCount = "entry_count"
)

// Index manages the bbolt database for malware data
type Index struct {
	db       *bolt.DB
	dbPath   string
	entries  []OSVEntry // Cache full entries for range matching
}

// NewIndex creates or opens an index database
func NewIndex(dataDir string) (*Index, error) {
	// Create data directory if it doesn't exist
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create data directory: %w", err)
	}

	dbPath := filepath.Join(dataDir, "malware.db")

	// Open database
	db, err := bolt.Open(dbPath, 0600, &bolt.Options{
		Timeout: 5 * time.Second,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Create buckets if they don't exist
	err = db.Update(func(tx *bolt.Tx) error {
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketPackages)); err != nil {
			return err
		}
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketMetadata)); err != nil {
			return err
		}
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketEntries)); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to create buckets: %w", err)
	}

	index := &Index{
		db:     db,
		dbPath: dbPath,
	}

	// Load entries into memory for range matching
	if err := index.loadEntries(); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to load entries: %w", err)
	}

	return index, nil
}

// Close closes the database
func (idx *Index) Close() error {
	if idx.db != nil {
		return idx.db.Close()
	}
	return nil
}

// GetMetadata retrieves sync metadata
func (idx *Index) GetMetadata() (*SyncMetadata, error) {
	var meta SyncMetadata

	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketMetadata))

		// Get last SHA
		if v := b.Get([]byte(keyLastSHA)); v != nil {
			meta.LastSHA = string(v)
		}

		// Get last sync time
		if v := b.Get([]byte(keyLastSync)); v != nil {
			var t time.Time
			if err := json.Unmarshal(v, &t); err == nil {
				meta.LastSync = t
			}
		}

		// Get entry count
		if v := b.Get([]byte(keyEntryCount)); v != nil {
			var count int
			if err := json.Unmarshal(v, &count); err == nil {
				meta.EntryCount = count
			}
		}

		return nil
	})

	return &meta, err
}

// Update updates the index with new data
func (idx *Index) Update(result *SyncResult) error {
	// Build index from entries
	packageIndex, err := BuildIndex(result.Entries)
	if err != nil {
		return fmt.Errorf("failed to build index: %w", err)
	}

	// Store in database
	err = idx.db.Update(func(tx *bolt.Tx) error {
		pkgBucket := tx.Bucket([]byte(bucketPackages))
		entriesBucket := tx.Bucket([]byte(bucketEntries))
		metaBucket := tx.Bucket([]byte(bucketMetadata))

		// Clear existing data (full rebuild)
		// For a more efficient update, we could implement incremental updates
		if err := tx.DeleteBucket([]byte(bucketPackages)); err != nil && err != bolt.ErrBucketNotFound {
			return err
		}
		if _, err := tx.CreateBucket([]byte(bucketPackages)); err != nil {
			return err
		}
		pkgBucket = tx.Bucket([]byte(bucketPackages))

		if err := tx.DeleteBucket([]byte(bucketEntries)); err != nil && err != bolt.ErrBucketNotFound {
			return err
		}
		if _, err := tx.CreateBucket([]byte(bucketEntries)); err != nil {
			return err
		}
		entriesBucket = tx.Bucket([]byte(bucketEntries))

		// Store package index
		for key, versions := range packageIndex {
			data, err := json.Marshal(versions)
			if err != nil {
				return fmt.Errorf("failed to marshal versions for %s: %w", key, err)
			}
			if err := pkgBucket.Put([]byte(key), data); err != nil {
				return err
			}
		}

		// Store full entries for range matching
		for _, entry := range result.Entries {
			data, err := json.Marshal(entry)
			if err != nil {
				return fmt.Errorf("failed to marshal entry %s: %w", entry.ID, err)
			}
			if err := entriesBucket.Put([]byte(entry.ID), data); err != nil {
				return err
			}
		}

		// Update metadata
		if err := metaBucket.Put([]byte(keyLastSHA), []byte(result.SHA)); err != nil {
			return err
		}

		syncTime, err := json.Marshal(time.Now())
		if err != nil {
			return err
		}
		if err := metaBucket.Put([]byte(keyLastSync), syncTime); err != nil {
			return err
		}

		countData, err := json.Marshal(result.EntryCount)
		if err != nil {
			return err
		}
		if err := metaBucket.Put([]byte(keyEntryCount), countData); err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return fmt.Errorf("failed to update database: %w", err)
	}

	// Reload entries cache
	if err := idx.loadEntries(); err != nil {
		return fmt.Errorf("failed to reload entries: %w", err)
	}

	return nil
}

// Lookup searches for malware findings for a specific package version
func (idx *Index) Lookup(ecosystem, name, version string) ([]MalwareFinding, error) {
	key := ecosystem + "/" + name

	var findings []MalwareFinding

	// First, check exact version matches in the index
	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketPackages))
		v := b.Get([]byte(key))
		if v == nil {
			return nil
		}

		var versions PackageVersions
		if err := json.Unmarshal(v, &versions); err != nil {
			return err
		}

		// Check for exact version match
		if malware, ok := versions[version]; ok {
			findings = append(findings, malware...)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Also check range-based matches using cached entries
	for _, entry := range idx.entries {
		for _, affected := range entry.Affected {
			if affected.Package.Ecosystem == ecosystem && affected.Package.Name == name {
				// Check if this version matches any ranges
				matched, err := MatchVersion(version, affected)
				if err != nil {
					// Log error but continue
					fmt.Fprintf(os.Stderr, "Warning: failed to match version for %s: %v\n", entry.ID, err)
					continue
				}

				if matched {
					finding := MalwareFinding{
						ID:      entry.ID,
						Summary: entry.Summary,
						Source:  "ossf-malicious-packages",
					}

					// Check if we already have this finding (to avoid duplicates)
					exists := false
					for _, f := range findings {
						if f.ID == finding.ID {
							exists = true
							break
						}
					}
					if !exists {
						findings = append(findings, finding)
					}
				}
			}
		}
	}

	return findings, nil
}

// loadEntries loads all OSV entries into memory for range matching
func (idx *Index) loadEntries() error {
	var entries []OSVEntry

	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketEntries))
		return b.ForEach(func(k, v []byte) error {
			var entry OSVEntry
			if err := json.Unmarshal(v, &entry); err != nil {
				return err
			}
			entries = append(entries, entry)
			return nil
		})
	})

	if err != nil {
		return err
	}

	idx.entries = entries
	return nil
}

// Stats returns statistics about the index
func (idx *Index) Stats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	err := idx.db.View(func(tx *bolt.Tx) error {
		pkgBucket := tx.Bucket([]byte(bucketPackages))
		entriesBucket := tx.Bucket([]byte(bucketEntries))

		stats["packages"] = pkgBucket.Stats().KeyN
		stats["entries"] = entriesBucket.Stats().KeyN
		stats["db_size"] = tx.Size()

		return nil
	})

	if err != nil {
		return nil, err
	}

	meta, err := idx.GetMetadata()
	if err != nil {
		return nil, err
	}

	stats["last_sha"] = meta.LastSHA
	stats["last_sync"] = meta.LastSync
	stats["entry_count"] = meta.EntryCount

	return stats, nil
}
