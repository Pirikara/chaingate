package ossfmalware

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	bolt "go.etcd.io/bbolt"
)

const (
	// Bucket names
	bucketPackages = "pkgs"
	bucketMetadata = "meta"
	bucketEntries  = "entries" // Store full OSV entries for range matching

	// Metadata keys
	keyLastSHA   = "last_sha"
	keyLastSync  = "last_sync"
	keyEntryCount = "entry_count"
)

// Index manages the bbolt database for malware data
type Index struct {
	db       *bolt.DB
	dbPath   string
	entries  []OSVEntry // Cache full entries for range matching
}

// NewIndex creates or opens an index database
func NewIndex(dataDir string) (*Index, error) {
	// Create data directory if it doesn't exist
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create data directory: %w", err)
	}

	dbPath := filepath.Join(dataDir, "malware.db")

	// Open database
	db, err := bolt.Open(dbPath, 0600, &bolt.Options{
		Timeout: 5 * time.Second,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Create buckets if they don't exist
	err = db.Update(func(tx *bolt.Tx) error {
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketPackages)); err != nil {
			return err
		}
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketMetadata)); err != nil {
			return err
		}
		if _, err := tx.CreateBucketIfNotExists([]byte(bucketEntries)); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to create buckets: %w", err)
	}

	index := &Index{
		db:     db,
		dbPath: dbPath,
	}

	// Load entries into memory for range matching
	if err := index.loadEntries(); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to load entries: %w", err)
	}

	return index, nil
}

// Close closes the database
func (idx *Index) Close() error {
	if idx.db != nil {
		return idx.db.Close()
	}
	return nil
}

// GetMetadata retrieves sync metadata
func (idx *Index) GetMetadata() (*SyncMetadata, error) {
	var meta SyncMetadata

	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketMetadata))

		// Get last SHA
		if v := b.Get([]byte(keyLastSHA)); v != nil {
			meta.LastSHA = string(v)
		}

		// Get last sync time
		if v := b.Get([]byte(keyLastSync)); v != nil {
			var t time.Time
			if err := json.Unmarshal(v, &t); err == nil {
				meta.LastSync = t
			}
		}

		// Get entry count
		if v := b.Get([]byte(keyEntryCount)); v != nil {
			var count int
			if err := json.Unmarshal(v, &count); err == nil {
				meta.EntryCount = count
			}
		}

		return nil
	})

	return &meta, err
}

// Update updates the index with new data
func (idx *Index) Update(result *SyncResult) error {
	// Build index from entries
	packageIndex, err := BuildIndex(result.Entries)
	if err != nil {
		return fmt.Errorf("failed to build index: %w", err)
	}

	// Store in database
	err = idx.db.Update(func(tx *bolt.Tx) error {
		pkgBucket := tx.Bucket([]byte(bucketPackages))
		entriesBucket := tx.Bucket([]byte(bucketEntries))
		metaBucket := tx.Bucket([]byte(bucketMetadata))

		// Clear existing data (full rebuild)
		// For a more efficient update, we could implement incremental updates
		if err := tx.DeleteBucket([]byte(bucketPackages)); err != nil && err != bolt.ErrBucketNotFound {
			return err
		}
		if _, err := tx.CreateBucket([]byte(bucketPackages)); err != nil {
			return err
		}
		pkgBucket = tx.Bucket([]byte(bucketPackages))

		if err := tx.DeleteBucket([]byte(bucketEntries)); err != nil && err != bolt.ErrBucketNotFound {
			return err
		}
		if _, err := tx.CreateBucket([]byte(bucketEntries)); err != nil {
			return err
		}
		entriesBucket = tx.Bucket([]byte(bucketEntries))

		// Store package index
		for key, versions := range packageIndex {
			data, err := json.Marshal(versions)
			if err != nil {
				return fmt.Errorf("failed to marshal versions for %s: %w", key, err)
			}
			if err := pkgBucket.Put([]byte(key), data); err != nil {
				return err
			}
		}

		// Store full entries for range matching
		for _, entry := range result.Entries {
			data, err := json.Marshal(entry)
			if err != nil {
				return fmt.Errorf("failed to marshal entry %s: %w", entry.ID, err)
			}
			if err := entriesBucket.Put([]byte(entry.ID), data); err != nil {
				return err
			}
		}

		// Update metadata
		if err := metaBucket.Put([]byte(keyLastSHA), []byte(result.SHA)); err != nil {
			return err
		}

		syncTime, err := json.Marshal(time.Now())
		if err != nil {
			return err
		}
		if err := metaBucket.Put([]byte(keyLastSync), syncTime); err != nil {
			return err
		}

		countData, err := json.Marshal(result.EntryCount)
		if err != nil {
			return err
		}
		if err := metaBucket.Put([]byte(keyEntryCount), countData); err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return fmt.Errorf("failed to update database: %w", err)
	}

	// Reload entries cache
	if err := idx.loadEntries(); err != nil {
		return fmt.Errorf("failed to reload entries: %w", err)
	}

	return nil
}

// normalizePythonPackageName normalizes a Python package name according to PEP 503
// This converts to lowercase and replaces ., -, _ with hyphens
func normalizePythonPackageName(name string) string {
	// Lowercase
	name = strings.ToLower(name)
	// Replace ., _, - with hyphens
	re := regexp.MustCompile(`[._-]+`)
	name = re.ReplaceAllString(name, "-")
	return name
}

// getPythonNameVariants generates possible name variants for PyPI package lookup
// Since OSSF stores original names, we need to try multiple variants
func getPythonNameVariants(name string) []string {
	normalized := normalizePythonPackageName(name)

	// Generate variants with different separators
	variants := make(map[string]bool)
	variants[name] = true                               // Original name
	variants[normalized] = true                         // Fully normalized (lowercase, hyphens)
	variants[strings.ReplaceAll(normalized, "-", "_")] = true // With underscores

	// Also try with original case preserved but different separators
	variants[strings.ReplaceAll(name, "_", "-")] = true
	variants[strings.ReplaceAll(name, "-", "_")] = true

	// Title case variant (for packages like Django)
	if len(normalized) > 0 {
		titleCase := strings.ToUpper(string(normalized[0])) + normalized[1:]
		variants[titleCase] = true
	}

	result := make([]string, 0, len(variants))
	for v := range variants {
		result = append(result, v)
	}
	return result
}

// Lookup searches for malware findings for a specific package version
func (idx *Index) Lookup(ecosystem, name, version string) ([]MalwareFinding, error) {
	var findings []MalwareFinding

	// For PyPI, try multiple name variants due to normalization differences
	var namesToTry []string
	if ecosystem == "PyPI" {
		namesToTry = getPythonNameVariants(name)
	} else {
		namesToTry = []string{name}
	}

	// First, check exact version matches in the index
	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketPackages))

		for _, tryName := range namesToTry {
			key := ecosystem + "/" + tryName
			v := b.Get([]byte(key))
			if v == nil {
				continue
			}

			var versions PackageVersions
			if err := json.Unmarshal(v, &versions); err != nil {
				return err
			}

			// Check for exact version match
			if malware, ok := versions[version]; ok {
				for _, finding := range malware {
					// Check if we already have this finding
					exists := false
					for _, f := range findings {
						if f.ID == finding.ID {
							exists = true
							break
						}
					}
					if !exists {
						findings = append(findings, finding)
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Also check range-based matches using cached entries
	for _, entry := range idx.entries {
		for _, affected := range entry.Affected {
			if affected.Package.Ecosystem != ecosystem {
				continue
			}

			// For PyPI, check if the affected name matches any of our variants
			nameMatches := false
			if ecosystem == "PyPI" {
				affectedVariants := getPythonNameVariants(affected.Package.Name)
				for _, av := range affectedVariants {
					for _, tv := range namesToTry {
						if av == tv {
							nameMatches = true
							break
						}
					}
					if nameMatches {
						break
					}
				}
			} else {
				nameMatches = affected.Package.Name == name
			}

			if !nameMatches {
				continue
			}

			// Check if this version matches any ranges
			matched, err := MatchVersion(version, affected)
			if err != nil {
				// Log error but continue
				fmt.Fprintf(os.Stderr, "Warning: failed to match version for %s: %v\n", entry.ID, err)
				continue
			}

			if matched {
				finding := MalwareFinding{
					ID:      entry.ID,
					Summary: entry.Summary,
					Source:  "ossf-malicious-packages",
				}

				// Check if we already have this finding (to avoid duplicates)
				exists := false
				for _, f := range findings {
					if f.ID == finding.ID {
						exists = true
						break
					}
				}
				if !exists {
					findings = append(findings, finding)
				}
			}
		}
	}

	return findings, nil
}

// loadEntries loads all OSV entries into memory for range matching
func (idx *Index) loadEntries() error {
	var entries []OSVEntry

	err := idx.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketEntries))
		return b.ForEach(func(k, v []byte) error {
			var entry OSVEntry
			if err := json.Unmarshal(v, &entry); err != nil {
				return err
			}
			entries = append(entries, entry)
			return nil
		})
	})

	if err != nil {
		return err
	}

	idx.entries = entries
	return nil
}

// Stats returns statistics about the index
func (idx *Index) Stats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	err := idx.db.View(func(tx *bolt.Tx) error {
		pkgBucket := tx.Bucket([]byte(bucketPackages))
		entriesBucket := tx.Bucket([]byte(bucketEntries))

		stats["packages"] = pkgBucket.Stats().KeyN
		stats["entries"] = entriesBucket.Stats().KeyN
		stats["db_size"] = tx.Size()

		return nil
	})

	if err != nil {
		return nil, err
	}

	meta, err := idx.GetMetadata()
	if err != nil {
		return nil, err
	}

	stats["last_sha"] = meta.LastSHA
	stats["last_sync"] = meta.LastSync
	stats["entry_count"] = meta.EntryCount

	return stats, nil
}
