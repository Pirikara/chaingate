package ossfmalware

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// Client is the main interface for OSSF malicious packages data
type Client struct {
	downloader *Downloader
	index      *Index
	dataDir    string
}

// NewClient creates a new OSSF malware client
func NewClient(dataDir string, githubToken string) (*Client, error) {
	// Use default data directory if not specified
	if dataDir == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return nil, fmt.Errorf("failed to get home directory: %w", err)
		}
		dataDir = filepath.Join(homeDir, ".chaingate", "feeds", "ossf")
	}

	// Create index
	index, err := NewIndex(dataDir)
	if err != nil {
		return nil, fmt.Errorf("failed to create index: %w", err)
	}

	// Create downloader
	downloader := NewDownloader(githubToken)

	return &Client{
		downloader: downloader,
		index:      index,
		dataDir:    dataDir,
	}, nil
}

// Close closes the client and releases resources
func (c *Client) Close() error {
	return c.index.Close()
}

// EnsureUpdated checks for updates and syncs if needed
// This should be called at startup of each chaingate execution
func (c *Client) EnsureUpdated(ctx context.Context) error {
	// Get current metadata
	meta, err := c.index.GetMetadata()
	if err != nil {
		return fmt.Errorf("failed to get metadata: %w", err)
	}

	// Check if we need to sync
	startTime := time.Now()
	result, err := c.downloader.Sync(ctx, meta.LastSHA)
	if err != nil {
		return fmt.Errorf("failed to sync: %w", err)
	}

	// If result is nil, we're already up to date
	if result == nil {
		return nil
	}

	// Show sync message
	fmt.Fprintf(os.Stderr, "ðŸ”„ Updating malware database... ")

	// Update index
	if err := c.index.Update(result); err != nil {
		fmt.Fprintf(os.Stderr, "failed\n")
		return fmt.Errorf("failed to update index: %w", err)
	}

	duration := time.Since(startTime)
	fmt.Fprintf(os.Stderr, "done (%d entries, %v)\n", result.EntryCount, duration.Round(time.Millisecond))

	return nil
}

// Lookup checks if a package version is malicious
func (c *Client) Lookup(ecosystem, name, version string) ([]MalwareFinding, error) {
	return c.index.Lookup(ecosystem, name, version)
}

// GetMetadata returns the current sync metadata
func (c *Client) GetMetadata() (*SyncMetadata, error) {
	return c.index.GetMetadata()
}

// GetStats returns statistics about the index
func (c *Client) GetStats() (map[string]interface{}, error) {
	return c.index.Stats()
}

// SelfCheck performs a self-check to verify the client is working correctly
func (c *Client) SelfCheck(ctx context.Context) error {
	// Check if we can connect to GitHub
	_, err := c.downloader.githubClient.GetLatestCommitSHA(ctx)
	if err != nil {
		return fmt.Errorf("failed to connect to GitHub: %w", err)
	}

	// Check if index is readable
	meta, err := c.GetMetadata()
	if err != nil {
		return fmt.Errorf("failed to read index: %w", err)
	}

	if meta.LastSHA == "" {
		return fmt.Errorf("index is empty - please run sync")
	}

	// Try a test lookup
	_, err = c.Lookup("npm", "safe-chain-test", "1.0.0")
	if err != nil {
		return fmt.Errorf("failed to perform lookup: %w", err)
	}

	return nil
}

// ForceSync forces a full sync regardless of current state
func (c *Client) ForceSync(ctx context.Context) error {
	// Get latest commit
	sha, err := c.downloader.githubClient.GetLatestCommitSHA(ctx)
	if err != nil {
		return fmt.Errorf("failed to get latest commit: %w", err)
	}

	// Download tarball
	tarball, err := c.downloader.githubClient.DownloadTarball(ctx, sha)
	if err != nil {
		return fmt.Errorf("failed to download tarball: %w", err)
	}
	defer tarball.Close()

	// Extract and parse
	entries, err := c.downloader.extractAndParseEntries(tarball)
	if err != nil {
		return fmt.Errorf("failed to extract entries: %w", err)
	}

	// Update index
	result := &SyncResult{
		SHA:        sha,
		EntryCount: len(entries),
		Entries:    entries,
	}

	if err := c.index.Update(result); err != nil {
		return fmt.Errorf("failed to update index: %w", err)
	}

	fmt.Fprintf(os.Stderr, "âœ… Sync complete: %d entries\n", result.EntryCount)
	return nil
}
