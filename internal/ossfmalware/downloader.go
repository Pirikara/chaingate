package ossfmalware

import (
	"archive/tar"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/Masterminds/semver/v3"
)

// Downloader handles downloading and extracting malware data
type Downloader struct {
	githubClient *GitHubClient
}

// NewDownloader creates a new downloader
func NewDownloader(githubToken string) *Downloader {
	return &Downloader{
		githubClient: NewGitHubClient(githubToken),
	}
}

// SyncResult contains the result of a sync operation
type SyncResult struct {
	SHA        string
	EntryCount int
	Entries    []OSVEntry
}

// Sync downloads and extracts the latest malware data
// Returns nil if the local SHA matches the remote SHA (no update needed)
func (d *Downloader) Sync(ctx context.Context, localSHA string) (*SyncResult, error) {
	// Check if update is needed
	remoteSHA, err := d.githubClient.GetLatestCommitSHA(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest commit SHA: %w", err)
	}

	if remoteSHA == localSHA {
		// No update needed
		return nil, nil
	}

	// Download tarball
	tarball, err := d.githubClient.DownloadTarball(ctx, remoteSHA)
	if err != nil {
		return nil, fmt.Errorf("failed to download tarball: %w", err)
	}
	defer tarball.Close()

	// Extract and parse entries
	entries, err := d.extractAndParseEntries(tarball)
	if err != nil {
		return nil, fmt.Errorf("failed to extract and parse entries: %w", err)
	}

	return &SyncResult{
		SHA:        remoteSHA,
		EntryCount: len(entries),
		Entries:    entries,
	}, nil
}

// extractAndParseEntries extracts the tarball and parses all JSON files
func (d *Downloader) extractAndParseEntries(tarball io.ReadCloser) ([]OSVEntry, error) {
	// Create gzip reader
	gzipReader, err := gzip.NewReader(tarball)
	if err != nil {
		return nil, fmt.Errorf("failed to create gzip reader: %w", err)
	}
	defer gzipReader.Close()

	// Create tar reader
	tarReader := tar.NewReader(gzipReader)

	var entries []OSVEntry

	// Read all files in the tarball
	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("failed to read tar entry: %w", err)
		}

		// We're only interested in JSON files in osv/malicious/ directory
		if !strings.Contains(header.Name, "/osv/malicious/") || !strings.HasSuffix(header.Name, ".json") {
			continue
		}

		// Skip directories
		if header.Typeflag == tar.TypeDir {
			continue
		}

		// Parse the JSON file
		var entry OSVEntry
		if err := json.NewDecoder(tarReader).Decode(&entry); err != nil {
			// Log but don't fail - some files might be malformed
			fmt.Fprintf(os.Stderr, "Warning: failed to parse %s: %v\n", header.Name, err)
			continue
		}

		entries = append(entries, entry)
	}

	return entries, nil
}

// BuildIndex builds a package version index from OSV entries
// Returns a map of "ecosystem/name" -> version -> []MalwareFinding
func BuildIndex(entries []OSVEntry) (map[string]PackageVersions, error) {
	index := make(map[string]PackageVersions)

	for _, entry := range entries {
		for _, affected := range entry.Affected {
			// Create key: ecosystem/name
			key := affected.Package.Ecosystem + "/" + affected.Package.Name

			// Initialize map if needed
			if index[key] == nil {
				index[key] = make(PackageVersions)
			}

			finding := MalwareFinding{
				ID:      entry.ID,
				Summary: entry.Summary,
				Source:  "ossf-malicious-packages",
			}

			// If explicit versions are listed, use them
			if len(affected.Versions) > 0 {
				for _, version := range affected.Versions {
					index[key][version] = append(index[key][version], finding)
				}
			}

			// Also check ranges
			if len(affected.Ranges) > 0 {
				// For ranges, we'll need to check versions at lookup time
				// Store range information in a special marker
				// We'll handle this in the lookup logic
				for _, r := range affected.Ranges {
					if r.Type == "SEMVER" {
						// Store a marker for range-based matching
						// The lookup logic will need to check these
						for _, event := range r.Events {
							if event.Introduced != "" {
								// Mark this entry as having a range
								// We'll store this with a special version marker
								rangeKey := fmt.Sprintf("__range:%s", entry.ID)
								if index[key][rangeKey] == nil {
									index[key][rangeKey] = []MalwareFinding{}
								}
								// Store the range information in the finding
								index[key][rangeKey] = append(index[key][rangeKey], finding)
							}
						}
					}
				}
			}
		}
	}

	return index, nil
}

// MatchVersion checks if a version matches any of the ranges in an OSV entry
func MatchVersion(version string, affected Affected) (bool, error) {
	// If explicit versions are listed, check them first
	for _, v := range affected.Versions {
		if v == version {
			return true, nil
		}
	}

	// Check ranges
	for _, r := range affected.Ranges {
		if r.Type == "SEMVER" {
			matched, err := matchSemverRange(version, r)
			if err != nil {
				return false, err
			}
			if matched {
				return true, nil
			}
		} else if r.Type == "ECOSYSTEM" || r.Type == "GIT" {
			// For non-semver ranges, we need exact version match
			// This is a simplified approach
			for _, v := range affected.Versions {
				if v == version {
					return true, nil
				}
			}
		}
	}

	return false, nil
}

// matchSemverRange checks if a version matches a semver range
func matchSemverRange(version string, r Range) (bool, error) {
	v, err := semver.NewVersion(version)
	if err != nil {
		// If it's not a valid semver, we can't match it
		return false, nil
	}

	for _, event := range r.Events {
		if event.Introduced != "" {
			// Check if version is >= introduced
			if event.Introduced == "0" {
				// Special case: "0" means all versions
				if event.Fixed != "" {
					// Check if version is < fixed
					fixed, err := semver.NewVersion(event.Fixed)
					if err != nil {
						continue
					}
					if v.LessThan(fixed) {
						return true, nil
					}
				} else if event.LastAffected != "" {
					// Check if version is <= last_affected
					lastAffected, err := semver.NewVersion(event.LastAffected)
					if err != nil {
						continue
					}
					if v.LessThan(lastAffected) || v.Equal(lastAffected) {
						return true, nil
					}
				} else {
					// No upper bound, all versions are affected
					return true, nil
				}
			} else {
				// Normal introduced version
				introduced, err := semver.NewVersion(event.Introduced)
				if err != nil {
					continue
				}

				if v.GreaterThan(introduced) || v.Equal(introduced) {
					// Check upper bound
					if event.Fixed != "" {
						fixed, err := semver.NewVersion(event.Fixed)
						if err != nil {
							continue
						}
						if v.LessThan(fixed) {
							return true, nil
						}
					} else if event.LastAffected != "" {
						lastAffected, err := semver.NewVersion(event.LastAffected)
						if err != nil {
							continue
						}
						if v.LessThan(lastAffected) || v.Equal(lastAffected) {
							return true, nil
						}
					} else {
						// No upper bound
						return true, nil
					}
				}
			}
		}
	}

	return false, nil
}

// SaveToTempFile saves entries to a temporary JSON file for debugging
func SaveToTempFile(entries []OSVEntry, filename string) error {
	tmpDir := filepath.Join(os.TempDir(), "chaingate-ossfmalware")
	if err := os.MkdirAll(tmpDir, 0755); err != nil {
		return err
	}

	filePath := filepath.Join(tmpDir, filename)
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(entries)
}
